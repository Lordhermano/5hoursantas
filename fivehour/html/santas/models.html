<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>santas.models API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>santas.models</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="santas.models.Destination"><code class="flex name class">
<span>class <span class="ident">Destination</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Destination(models.Model):
    &#39;&#39;&#39;This model is used to auto generate the content for a particular holiday 
    and save the images in the database so they could be used by any user.
    
    This makes sure the images and other data are not lost went sending them 
    to the user.&#39;&#39;&#39;
    main_img = models.ImageField(upload_to=&#39;static/images/&#39;)
    second_img = models.ImageField(upload_to=&#39;static/images/&#39;)
    Title = models.CharField(max_length=20)
    Overview_desc = models.CharField(max_length=1000)
    Travel_Guide_desc = models.CharField(max_length=1000,default=0)
    Things_to_do_desc = models.CharField(max_length=1000,default=0)
    adult_price = models.CharField(max_length=20)
    children_price = models.CharField(max_length=20)
    infants_price = models.CharField(max_length=20)</code></pre>
</details>
<div class="desc"><p>This model is used to auto generate the content for a particular holiday
and save the images in the database so they could be used by any user.</p>
<p>This makes sure the images and other data are not lost went sending them
to the user.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.db.models.base.Model</li>
<li>django.db.models.utils.AltersData</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="santas.models.Destination.DoesNotExist"><code class="name">var <span class="ident">DoesNotExist</span></code></dt>
<dd>
<div class="desc"><p>The requested object does not exist</p></div>
</dd>
<dt id="santas.models.Destination.MultipleObjectsReturned"><code class="name">var <span class="ident">MultipleObjectsReturned</span></code></dt>
<dd>
<div class="desc"><p>The query returned multiple objects when only one was expected.</p></div>
</dd>
<dt id="santas.models.Destination.objects"><code class="name">var <span class="ident">objects</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="santas.models.Destination.Overview_desc"><code class="name">var <span class="ident">Overview_desc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.Things_to_do_desc"><code class="name">var <span class="ident">Things_to_do_desc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.Title"><code class="name">var <span class="ident">Title</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.Travel_Guide_desc"><code class="name">var <span class="ident">Travel_Guide_desc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.adult_price"><code class="name">var <span class="ident">adult_price</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.children_price"><code class="name">var <span class="ident">children_price</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.infants_price"><code class="name">var <span class="ident">infants_price</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            if instance.pk is None and self.field.generated:
                raise AttributeError(
                    &#34;Cannot read a generated field from an unsaved model.&#34;
                )
            instance.refresh_from_db(fields=[field_name])
        else:
            data[field_name] = val
    return data[field_name]</code></pre>
</details>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
</dd>
<dt id="santas.models.Destination.main_img"><code class="name">var <span class="ident">main_img</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    if instance is None:
        return self

    # This is slightly complicated, so worth an explanation.
    # instance.file needs to ultimately return some instance of `File`,
    # probably a subclass. Additionally, this returned object needs to have
    # the FieldFile API so that users can easily do things like
    # instance.file.path and have that delegated to the file storage engine.
    # Easy enough if we&#39;re strict about assignment in __set__, but if you
    # peek below you can see that we&#39;re not. So depending on the current
    # value of the field we have to dynamically construct some sort of
    # &#34;thing&#34; to return.

    # The instance dict contains whatever was originally assigned
    # in __set__.
    file = super().__get__(instance, cls)

    # If this value is a string (instance.file = &#34;path/to/file&#34;) or None
    # then we simply wrap it with the appropriate attribute class according
    # to the file field. [This is FieldFile for FileFields and
    # ImageFieldFile for ImageFields; it&#39;s also conceivable that user
    # subclasses might also want to subclass the attribute class]. This
    # object understands how to convert a path to a file, and also how to
    # handle None.
    if isinstance(file, str) or file is None:
        attr = self.field.attr_class(instance, self.field, file)
        instance.__dict__[self.field.attname] = attr

    # If this value is a DatabaseDefault, initialize the attribute class
    # for this field with its db_default value.
    elif isinstance(file, DatabaseDefault):
        attr = self.field.attr_class(instance, self.field, self.field.db_default)
        instance.__dict__[self.field.attname] = attr

    # Other types of files may be assigned as well, but they need to have
    # the FieldFile interface added to them. Thus, we wrap any other type of
    # File inside a FieldFile (well, the field&#39;s attr_class, which is
    # usually FieldFile).
    elif isinstance(file, File) and not isinstance(file, FieldFile):
        file_copy = self.field.attr_class(instance, self.field, file.name)
        file_copy.file = file
        file_copy._committed = False
        instance.__dict__[self.field.attname] = file_copy

    # Finally, because of the (some would say boneheaded) way pickle works,
    # the underlying FieldFile might not actually itself have an associated
    # file. So we need to reset the details of the FieldFile in those cases.
    elif isinstance(file, FieldFile) and not hasattr(file, &#34;field&#34;):
        file.instance = instance
        file.field = self.field
        file.storage = self.field.storage

    # Make sure that the instance is correct.
    elif isinstance(file, FieldFile) and instance is not file.instance:
        file.instance = instance

    # That was fun, wasn&#39;t it?
    return instance.__dict__[self.field.attname]</code></pre>
</details>
<div class="desc"><p>Just like the FileDescriptor, but for ImageFields. The only difference is
assigning the width/height to the width_field/height_field, if appropriate.</p></div>
</dd>
<dt id="santas.models.Destination.second_img"><code class="name">var <span class="ident">second_img</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    if instance is None:
        return self

    # This is slightly complicated, so worth an explanation.
    # instance.file needs to ultimately return some instance of `File`,
    # probably a subclass. Additionally, this returned object needs to have
    # the FieldFile API so that users can easily do things like
    # instance.file.path and have that delegated to the file storage engine.
    # Easy enough if we&#39;re strict about assignment in __set__, but if you
    # peek below you can see that we&#39;re not. So depending on the current
    # value of the field we have to dynamically construct some sort of
    # &#34;thing&#34; to return.

    # The instance dict contains whatever was originally assigned
    # in __set__.
    file = super().__get__(instance, cls)

    # If this value is a string (instance.file = &#34;path/to/file&#34;) or None
    # then we simply wrap it with the appropriate attribute class according
    # to the file field. [This is FieldFile for FileFields and
    # ImageFieldFile for ImageFields; it&#39;s also conceivable that user
    # subclasses might also want to subclass the attribute class]. This
    # object understands how to convert a path to a file, and also how to
    # handle None.
    if isinstance(file, str) or file is None:
        attr = self.field.attr_class(instance, self.field, file)
        instance.__dict__[self.field.attname] = attr

    # If this value is a DatabaseDefault, initialize the attribute class
    # for this field with its db_default value.
    elif isinstance(file, DatabaseDefault):
        attr = self.field.attr_class(instance, self.field, self.field.db_default)
        instance.__dict__[self.field.attname] = attr

    # Other types of files may be assigned as well, but they need to have
    # the FieldFile interface added to them. Thus, we wrap any other type of
    # File inside a FieldFile (well, the field&#39;s attr_class, which is
    # usually FieldFile).
    elif isinstance(file, File) and not isinstance(file, FieldFile):
        file_copy = self.field.attr_class(instance, self.field, file.name)
        file_copy.file = file
        file_copy._committed = False
        instance.__dict__[self.field.attname] = file_copy

    # Finally, because of the (some would say boneheaded) way pickle works,
    # the underlying FieldFile might not actually itself have an associated
    # file. So we need to reset the details of the FieldFile in those cases.
    elif isinstance(file, FieldFile) and not hasattr(file, &#34;field&#34;):
        file.instance = instance
        file.field = self.field
        file.storage = self.field.storage

    # Make sure that the instance is correct.
    elif isinstance(file, FieldFile) and instance is not file.instance:
        file.instance = instance

    # That was fun, wasn&#39;t it?
    return instance.__dict__[self.field.attname]</code></pre>
</details>
<div class="desc"><p>Just like the FileDescriptor, but for ImageFields. The only difference is
assigning the width/height to the width_field/height_field, if appropriate.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="santas" href="index.html">santas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="santas.models.Destination" href="#santas.models.Destination">Destination</a></code></h4>
<ul class="">
<li><code><a title="santas.models.Destination.DoesNotExist" href="#santas.models.Destination.DoesNotExist">DoesNotExist</a></code></li>
<li><code><a title="santas.models.Destination.MultipleObjectsReturned" href="#santas.models.Destination.MultipleObjectsReturned">MultipleObjectsReturned</a></code></li>
<li><code><a title="santas.models.Destination.Overview_desc" href="#santas.models.Destination.Overview_desc">Overview_desc</a></code></li>
<li><code><a title="santas.models.Destination.Things_to_do_desc" href="#santas.models.Destination.Things_to_do_desc">Things_to_do_desc</a></code></li>
<li><code><a title="santas.models.Destination.Title" href="#santas.models.Destination.Title">Title</a></code></li>
<li><code><a title="santas.models.Destination.Travel_Guide_desc" href="#santas.models.Destination.Travel_Guide_desc">Travel_Guide_desc</a></code></li>
<li><code><a title="santas.models.Destination.adult_price" href="#santas.models.Destination.adult_price">adult_price</a></code></li>
<li><code><a title="santas.models.Destination.children_price" href="#santas.models.Destination.children_price">children_price</a></code></li>
<li><code><a title="santas.models.Destination.id" href="#santas.models.Destination.id">id</a></code></li>
<li><code><a title="santas.models.Destination.infants_price" href="#santas.models.Destination.infants_price">infants_price</a></code></li>
<li><code><a title="santas.models.Destination.main_img" href="#santas.models.Destination.main_img">main_img</a></code></li>
<li><code><a title="santas.models.Destination.objects" href="#santas.models.Destination.objects">objects</a></code></li>
<li><code><a title="santas.models.Destination.second_img" href="#santas.models.Destination.second_img">second_img</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
